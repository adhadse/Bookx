use crate::config;
use crate::deps::*;
use crate::settings::{settings_manager, Key};

use adw::subclass::application_window::AdwApplicationWindowImpl;
use adw::subclass::prelude::*;
use gtk::prelude::*;
use gtk::{
    subclass::prelude::{ApplicationWindowImpl, WindowImpl, WindowImplExt},
    subclass::widget::{
        CompositeTemplate, CompositeTemplateCallbacks, TemplateChild, WidgetClassSubclassExt,
        WidgetImpl,
    },
    CompositeTemplate,
};

mod imp {
    use super::*;

    // To use composite templates, you need
    // to use derive macro. Derive macros generate
    // code to e.g. implement a trait on something.
    // In this case, code is generated for Debug output
    // and to handle binding the template children.
    //
    // For this derive macro, you need to have
    // `use gtk::CompositeTemplate` in your code.
    //
    // Because all of our member fields implement the
    // `Default` trait, we can use `#[derive(Default)]`.
    // If some member fields did not implement default,
    // we'd need to have a `new()` function in the
    // `impl ObjectSubclass for $TYPE` section.
    #[derive(Default, Debug, CompositeTemplate)]
    #[template(resource = "/com/anuragdhadse/Bookx/ui/window.ui")]
    pub struct BookxWindow {
        // Template children are used with the
        // TemplateChild<T> wrapper, where T is the
        // object type of the template child.
        #[template_child]
        pub headerbar: TemplateChild<adw::HeaderBar>,
    }

    #[glib::object_subclass]
    impl ObjectSubclass for BookxWindow {
        const NAME: &'static str = "BookxWindow";
        type Type = super::BookxWindow;
        type ParentType = adw::ApplicationWindow;

        fn class_init(klass: &mut Self::Class) {
            // bind_template() is a function generated by the
            // CompositeTemplate macro to bind all children at once.
            Self::bind_template(klass);
            Self::Type::bind_template_callbacks(klass);

            // Set up actions here ...
        }

        // You must call `Widget`'s `ini// Set up actionst_template()` within `instance_init()`.
        fn instance_init(obj: &glib::subclass::InitializingObject<Self>) {
            obj.init_template();
        }
    }

    impl ObjectImpl for BookxWindow {
        fn constructed(&self, obj: &Self::Type) {
            self.parent_constructed(obj);

            // Devel Profile
            if config::PROFILE == "Devel" {
                obj.add_css_class("devel");
            }

            // Load latest window state
            obj.load_window_size();
        }
    }

    impl WidgetImpl for BookxWindow {}
    impl WindowImpl for BookxWindow {
        // Save window state on delete event
        fn close_request(&self, window: &Self::Type) -> gtk::Inhibit {
            if let Err(err) = window.save_window_size() {
                log::warn!("Failed to save window state, {}", &err);
            }

            // Pass close request on to the parent
            self.parent_close_request(window)
        }
    }

    impl ApplicationWindowImpl for BookxWindow {}
    impl AdwApplicationWindowImpl for BookxWindow {}
}

glib::wrapper! {
    pub struct BookxWindow(ObjectSubclass<imp::BookxWindow>)
        @extends gtk::Widget, gtk::Window, gtk::ApplicationWindow, adw::ApplicationWindow,
        @implements gio::ActionMap, gio::ActionGroup, gtk::Root;
}

#[gtk::template_callbacks]
impl BookxWindow {
    pub fn new<A: IsA<gtk::Application>>(app: &A) -> Self {
        glib::Object::new(&[("application", app)]).expect("Failed to create BookxWindow")
    }

    fn save_window_size(&self) -> Result<(), glib::BoolError> {
        let (width, height) = self.default_size();

        settings_manager::set_integer(Key::WindowWidth, width);
        settings_manager::set_integer(Key::WindowHeight, height);

        settings_manager::set_boolean(Key::IsMaximized, self.is_maximized());

        Ok(())
    }

    fn load_window_size(&self) {
        let width = settings_manager::integer(Key::WindowWidth);
        let height = settings_manager::integer(Key::WindowHeight);
        let is_maximized = settings_manager::boolean(Key::IsMaximized);

        self.set_default_size(width, height);

        if is_maximized {
            self.maximize();
        }
    }

    #[template_callback]
    fn window_title(&self) -> String {
        config::NAME.to_string()
    }
}
